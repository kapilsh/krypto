// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SERIALIZATION_KRYPTO_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_SERIALIZATION_KRYPTO_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"

namespace krypto {
namespace serialization {

struct Empty;

struct SequenceNumber;

struct Heartbeat;

struct Instrument;

struct Quote;

struct SnapshotPriceLevel;

struct Snapshot;

struct IncrementalPriceLevel;

struct Incremental;

struct Trade;

struct InstrumentRequest;

struct InstrumentResponse;

struct InstrumentRefreshRequest;

struct OrderRequest;

struct OrderCancelRequest;

struct OrderReplaceRequest;

struct OrderUpdate;

struct Order;

struct Position;

struct RiskSummary;

struct TheoreticalSnapshot;

enum Exchange {
  Exchange_SIM = 0,
  Exchange_COINBASE = 1,
  Exchange_MIN = Exchange_SIM,
  Exchange_MAX = Exchange_COINBASE
};

inline const Exchange (&EnumValuesExchange())[2] {
  static const Exchange values[] = {
    Exchange_SIM,
    Exchange_COINBASE
  };
  return values;
}

inline const char * const *EnumNamesExchange() {
  static const char * const names[] = {
    "SIM",
    "COINBASE",
    nullptr
  };
  return names;
}

inline const char *EnumNameExchange(Exchange e) {
  if (e < Exchange_SIM || e > Exchange_COINBASE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExchange()[index];
}

enum Side {
  Side_UNKNOWN = 0,
  Side_BUY = 1,
  Side_SELL = 2,
  Side_MIN = Side_UNKNOWN,
  Side_MAX = Side_SELL
};

inline const Side (&EnumValuesSide())[3] {
  static const Side values[] = {
    Side_UNKNOWN,
    Side_BUY,
    Side_SELL
  };
  return values;
}

inline const char * const *EnumNamesSide() {
  static const char * const names[] = {
    "UNKNOWN",
    "BUY",
    "SELL",
    nullptr
  };
  return names;
}

inline const char *EnumNameSide(Side e) {
  if (e < Side_UNKNOWN || e > Side_SELL) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSide()[index];
}

enum OrderSide {
  OrderSide_UNKNOWN = 0,
  OrderSide_BID = 1,
  OrderSide_ASK = 2,
  OrderSide_MIN = OrderSide_UNKNOWN,
  OrderSide_MAX = OrderSide_ASK
};

inline const OrderSide (&EnumValuesOrderSide())[3] {
  static const OrderSide values[] = {
    OrderSide_UNKNOWN,
    OrderSide_BID,
    OrderSide_ASK
  };
  return values;
}

inline const char * const *EnumNamesOrderSide() {
  static const char * const names[] = {
    "UNKNOWN",
    "BID",
    "ASK",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrderSide(OrderSide e) {
  if (e < OrderSide_UNKNOWN || e > OrderSide_ASK) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderSide()[index];
}

enum OrderStatus {
  OrderStatus_UNKNOWN = 0,
  OrderStatus_IN_FLIGHT = 1,
  OrderStatus_CANCEL_IN_FLIGHT = 2,
  OrderStatus_REPLACE_IN_FLIGHT = 3,
  OrderStatus_NEW = 4,
  OrderStatus_ACCEPTED = 5,
  OrderStatus_CANCELLED = 6,
  OrderStatus_REPLACED = 7,
  OrderStatus_REJECTED = 8,
  OrderStatus_CANCEL_REJECTED = 9,
  OrderStatus_REPLACE_REJECTED = 10,
  OrderStatus_FILLED = 11,
  OrderStatus_PARTIALLY_FILLED = 12,
  OrderStatus_EXPIRED = 13,
  OrderStatus_DONE = 14,
  OrderStatus_MIN = OrderStatus_UNKNOWN,
  OrderStatus_MAX = OrderStatus_DONE
};

inline const OrderStatus (&EnumValuesOrderStatus())[15] {
  static const OrderStatus values[] = {
    OrderStatus_UNKNOWN,
    OrderStatus_IN_FLIGHT,
    OrderStatus_CANCEL_IN_FLIGHT,
    OrderStatus_REPLACE_IN_FLIGHT,
    OrderStatus_NEW,
    OrderStatus_ACCEPTED,
    OrderStatus_CANCELLED,
    OrderStatus_REPLACED,
    OrderStatus_REJECTED,
    OrderStatus_CANCEL_REJECTED,
    OrderStatus_REPLACE_REJECTED,
    OrderStatus_FILLED,
    OrderStatus_PARTIALLY_FILLED,
    OrderStatus_EXPIRED,
    OrderStatus_DONE
  };
  return values;
}

inline const char * const *EnumNamesOrderStatus() {
  static const char * const names[] = {
    "UNKNOWN",
    "IN_FLIGHT",
    "CANCEL_IN_FLIGHT",
    "REPLACE_IN_FLIGHT",
    "NEW",
    "ACCEPTED",
    "CANCELLED",
    "REPLACED",
    "REJECTED",
    "CANCEL_REJECTED",
    "REPLACE_REJECTED",
    "FILLED",
    "PARTIALLY_FILLED",
    "EXPIRED",
    "DONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrderStatus(OrderStatus e) {
  if (e < OrderStatus_UNKNOWN || e > OrderStatus_DONE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrderStatus()[index];
}

enum TimeInForce {
  TimeInForce_DAY = 0,
  TimeInForce_IOC = 1,
  TimeInForce_FOK = 2,
  TimeInForce_GTC = 3,
  TimeInForce_GTT = 4,
  TimeInForce_MIN = TimeInForce_DAY,
  TimeInForce_MAX = TimeInForce_GTT
};

inline const TimeInForce (&EnumValuesTimeInForce())[5] {
  static const TimeInForce values[] = {
    TimeInForce_DAY,
    TimeInForce_IOC,
    TimeInForce_FOK,
    TimeInForce_GTC,
    TimeInForce_GTT
  };
  return values;
}

inline const char * const *EnumNamesTimeInForce() {
  static const char * const names[] = {
    "DAY",
    "IOC",
    "FOK",
    "GTC",
    "GTT",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeInForce(TimeInForce e) {
  if (e < TimeInForce_DAY || e > TimeInForce_GTT) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeInForce()[index];
}

enum InstrumentType {
  InstrumentType_UNKNOWN = 0,
  InstrumentType_STOCK = 1,
  InstrumentType_FUTURE = 2,
  InstrumentType_OPTION = 3,
  InstrumentType_FOREX = 4,
  InstrumentType_CRYPTO = 5,
  InstrumentType_MIN = InstrumentType_UNKNOWN,
  InstrumentType_MAX = InstrumentType_CRYPTO
};

inline const InstrumentType (&EnumValuesInstrumentType())[6] {
  static const InstrumentType values[] = {
    InstrumentType_UNKNOWN,
    InstrumentType_STOCK,
    InstrumentType_FUTURE,
    InstrumentType_OPTION,
    InstrumentType_FOREX,
    InstrumentType_CRYPTO
  };
  return values;
}

inline const char * const *EnumNamesInstrumentType() {
  static const char * const names[] = {
    "UNKNOWN",
    "STOCK",
    "FUTURE",
    "OPTION",
    "FOREX",
    "CRYPTO",
    nullptr
  };
  return names;
}

inline const char *EnumNameInstrumentType(InstrumentType e) {
  if (e < InstrumentType_UNKNOWN || e > InstrumentType_CRYPTO) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInstrumentType()[index];
}

enum Currency {
  Currency_UNKNOWN = 0,
  Currency_BAT = 1,
  Currency_BCH = 2,
  Currency_BTC = 3,
  Currency_CVC = 4,
  Currency_DAI = 5,
  Currency_DNT = 6,
  Currency_EOS = 7,
  Currency_ETC = 8,
  Currency_ETH = 9,
  Currency_EUR = 10,
  Currency_GBP = 11,
  Currency_GNT = 12,
  Currency_LINK = 13,
  Currency_LOOM = 14,
  Currency_LTC = 15,
  Currency_MANA = 16,
  Currency_REP = 17,
  Currency_USD = 18,
  Currency_USDC = 19,
  Currency_XLM = 20,
  Currency_XRP = 21,
  Currency_ZEC = 22,
  Currency_ZRX = 23,
  Currency_XTZ = 24,
  Currency_ALGO = 25,
  Currency_DASH = 26,
  Currency_OXT = 27,
  Currency_ATOM = 28,
  Currency_KNC = 29,
  Currency_MIN = Currency_UNKNOWN,
  Currency_MAX = Currency_KNC
};

inline const Currency (&EnumValuesCurrency())[30] {
  static const Currency values[] = {
    Currency_UNKNOWN,
    Currency_BAT,
    Currency_BCH,
    Currency_BTC,
    Currency_CVC,
    Currency_DAI,
    Currency_DNT,
    Currency_EOS,
    Currency_ETC,
    Currency_ETH,
    Currency_EUR,
    Currency_GBP,
    Currency_GNT,
    Currency_LINK,
    Currency_LOOM,
    Currency_LTC,
    Currency_MANA,
    Currency_REP,
    Currency_USD,
    Currency_USDC,
    Currency_XLM,
    Currency_XRP,
    Currency_ZEC,
    Currency_ZRX,
    Currency_XTZ,
    Currency_ALGO,
    Currency_DASH,
    Currency_OXT,
    Currency_ATOM,
    Currency_KNC
  };
  return values;
}

inline const char * const *EnumNamesCurrency() {
  static const char * const names[] = {
    "UNKNOWN",
    "BAT",
    "BCH",
    "BTC",
    "CVC",
    "DAI",
    "DNT",
    "EOS",
    "ETC",
    "ETH",
    "EUR",
    "GBP",
    "GNT",
    "LINK",
    "LOOM",
    "LTC",
    "MANA",
    "REP",
    "USD",
    "USDC",
    "XLM",
    "XRP",
    "ZEC",
    "ZRX",
    "XTZ",
    "ALGO",
    "DASH",
    "OXT",
    "ATOM",
    "KNC",
    nullptr
  };
  return names;
}

inline const char *EnumNameCurrency(Currency e) {
  if (e < Currency_UNKNOWN || e > Currency_KNC) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCurrency()[index];
}

enum RequestType {
  RequestType_INVALID = 0,
  RequestType_ALL = 1,
  RequestType_ID = 2,
  RequestType_EXCHANGE = 3,
  RequestType_PRODUCT = 4,
  RequestType_MIN = RequestType_INVALID,
  RequestType_MAX = RequestType_PRODUCT
};

inline const RequestType (&EnumValuesRequestType())[5] {
  static const RequestType values[] = {
    RequestType_INVALID,
    RequestType_ALL,
    RequestType_ID,
    RequestType_EXCHANGE,
    RequestType_PRODUCT
  };
  return values;
}

inline const char * const *EnumNamesRequestType() {
  static const char * const names[] = {
    "INVALID",
    "ALL",
    "ID",
    "EXCHANGE",
    "PRODUCT",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestType(RequestType e) {
  if (e < RequestType_INVALID || e > RequestType_PRODUCT) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) SnapshotPriceLevel FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t price_;
  int64_t quantity_;

 public:
  SnapshotPriceLevel() {
    memset(static_cast<void *>(this), 0, sizeof(SnapshotPriceLevel));
  }
  SnapshotPriceLevel(int64_t _price, int64_t _quantity)
      : price_(flatbuffers::EndianScalar(_price)),
        quantity_(flatbuffers::EndianScalar(_quantity)) {
  }
  int64_t price() const {
    return flatbuffers::EndianScalar(price_);
  }
  int64_t quantity() const {
    return flatbuffers::EndianScalar(quantity_);
  }
};
FLATBUFFERS_STRUCT_END(SnapshotPriceLevel, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) IncrementalPriceLevel FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t price_;
  int64_t quantity_;
  int64_t side_;

 public:
  IncrementalPriceLevel() {
    memset(static_cast<void *>(this), 0, sizeof(IncrementalPriceLevel));
  }
  IncrementalPriceLevel(int64_t _price, int64_t _quantity, int64_t _side)
      : price_(flatbuffers::EndianScalar(_price)),
        quantity_(flatbuffers::EndianScalar(_quantity)),
        side_(flatbuffers::EndianScalar(_side)) {
  }
  int64_t price() const {
    return flatbuffers::EndianScalar(price_);
  }
  int64_t quantity() const {
    return flatbuffers::EndianScalar(quantity_);
  }
  int64_t side() const {
    return flatbuffers::EndianScalar(side_);
  }
};
FLATBUFFERS_STRUCT_END(IncrementalPriceLevel, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Position FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t security_id_;
  int64_t position_;

 public:
  Position() {
    memset(static_cast<void *>(this), 0, sizeof(Position));
  }
  Position(int64_t _security_id, int64_t _position)
      : security_id_(flatbuffers::EndianScalar(_security_id)),
        position_(flatbuffers::EndianScalar(_position)) {
  }
  int64_t security_id() const {
    return flatbuffers::EndianScalar(security_id_);
  }
  int64_t position() const {
    return flatbuffers::EndianScalar(position_);
  }
};
FLATBUFFERS_STRUCT_END(Position, 16);

struct Empty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EmptyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EmptyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmptyBuilder &operator=(const EmptyBuilder &);
  flatbuffers::Offset<Empty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Empty>(end);
    return o;
  }
};

inline flatbuffers::Offset<Empty> CreateEmpty(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EmptyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SequenceNumber FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct SequenceNumberBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(SequenceNumber::VT_VALUE, value, 0);
  }
  explicit SequenceNumberBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequenceNumberBuilder &operator=(const SequenceNumberBuilder &);
  flatbuffers::Offset<SequenceNumber> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceNumber>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceNumber> CreateSequenceNumber(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  SequenceNumberBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Heartbeat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SECURITY_ID = 4,
    VT_TIMESTAMP = 6
  };
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           verifier.EndTable();
  }
};

struct HeartbeatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(Heartbeat::VT_SECURITY_ID, security_id, 0);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Heartbeat::VT_TIMESTAMP, timestamp, 0);
  }
  explicit HeartbeatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeartbeatBuilder &operator=(const HeartbeatBuilder &);
  flatbuffers::Offset<Heartbeat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Heartbeat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Heartbeat> CreateHeartbeat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t security_id = 0,
    int64_t timestamp = 0) {
  HeartbeatBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_security_id(security_id);
  return builder_.Finish();
}

struct Instrument FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_SYMBOL = 8,
    VT_EXCHANGE = 10,
    VT_EXCHANGE_SYMBOL = 12,
    VT_TICK_SIZE = 14,
    VT_MIN_SIZE = 16,
    VT_MAX_SIZE = 18,
    VT_CRYPTO_BASE = 20,
    VT_CRYPTO_QUOTE = 22,
    VT_ACTIVE = 24,
    VT_SANDBOX_ENABLED = 26
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  InstrumentType type() const {
    return static_cast<InstrumentType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  Exchange exchange() const {
    return static_cast<Exchange>(GetField<int8_t>(VT_EXCHANGE, 0));
  }
  const flatbuffers::String *exchange_symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE_SYMBOL);
  }
  double tick_size() const {
    return GetField<double>(VT_TICK_SIZE, 0.0);
  }
  double min_size() const {
    return GetField<double>(VT_MIN_SIZE, 0.0);
  }
  double max_size() const {
    return GetField<double>(VT_MAX_SIZE, 0.0);
  }
  Currency crypto_base() const {
    return static_cast<Currency>(GetField<int8_t>(VT_CRYPTO_BASE, 0));
  }
  Currency crypto_quote() const {
    return static_cast<Currency>(GetField<int8_t>(VT_CRYPTO_QUOTE, 0));
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  bool sandbox_enabled() const {
    return GetField<uint8_t>(VT_SANDBOX_ENABLED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<int8_t>(verifier, VT_EXCHANGE) &&
           VerifyOffset(verifier, VT_EXCHANGE_SYMBOL) &&
           verifier.VerifyString(exchange_symbol()) &&
           VerifyField<double>(verifier, VT_TICK_SIZE) &&
           VerifyField<double>(verifier, VT_MIN_SIZE) &&
           VerifyField<double>(verifier, VT_MAX_SIZE) &&
           VerifyField<int8_t>(verifier, VT_CRYPTO_BASE) &&
           VerifyField<int8_t>(verifier, VT_CRYPTO_QUOTE) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           VerifyField<uint8_t>(verifier, VT_SANDBOX_ENABLED) &&
           verifier.EndTable();
  }
};

struct InstrumentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(Instrument::VT_ID, id, 0);
  }
  void add_type(InstrumentType type) {
    fbb_.AddElement<int8_t>(Instrument::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(Instrument::VT_SYMBOL, symbol);
  }
  void add_exchange(Exchange exchange) {
    fbb_.AddElement<int8_t>(Instrument::VT_EXCHANGE, static_cast<int8_t>(exchange), 0);
  }
  void add_exchange_symbol(flatbuffers::Offset<flatbuffers::String> exchange_symbol) {
    fbb_.AddOffset(Instrument::VT_EXCHANGE_SYMBOL, exchange_symbol);
  }
  void add_tick_size(double tick_size) {
    fbb_.AddElement<double>(Instrument::VT_TICK_SIZE, tick_size, 0.0);
  }
  void add_min_size(double min_size) {
    fbb_.AddElement<double>(Instrument::VT_MIN_SIZE, min_size, 0.0);
  }
  void add_max_size(double max_size) {
    fbb_.AddElement<double>(Instrument::VT_MAX_SIZE, max_size, 0.0);
  }
  void add_crypto_base(Currency crypto_base) {
    fbb_.AddElement<int8_t>(Instrument::VT_CRYPTO_BASE, static_cast<int8_t>(crypto_base), 0);
  }
  void add_crypto_quote(Currency crypto_quote) {
    fbb_.AddElement<int8_t>(Instrument::VT_CRYPTO_QUOTE, static_cast<int8_t>(crypto_quote), 0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(Instrument::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  void add_sandbox_enabled(bool sandbox_enabled) {
    fbb_.AddElement<uint8_t>(Instrument::VT_SANDBOX_ENABLED, static_cast<uint8_t>(sandbox_enabled), 0);
  }
  explicit InstrumentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstrumentBuilder &operator=(const InstrumentBuilder &);
  flatbuffers::Offset<Instrument> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Instrument>(end);
    return o;
  }
};

inline flatbuffers::Offset<Instrument> CreateInstrument(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    InstrumentType type = InstrumentType_UNKNOWN,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    Exchange exchange = Exchange_SIM,
    flatbuffers::Offset<flatbuffers::String> exchange_symbol = 0,
    double tick_size = 0.0,
    double min_size = 0.0,
    double max_size = 0.0,
    Currency crypto_base = Currency_UNKNOWN,
    Currency crypto_quote = Currency_UNKNOWN,
    bool active = false,
    bool sandbox_enabled = false) {
  InstrumentBuilder builder_(_fbb);
  builder_.add_max_size(max_size);
  builder_.add_min_size(min_size);
  builder_.add_tick_size(tick_size);
  builder_.add_id(id);
  builder_.add_exchange_symbol(exchange_symbol);
  builder_.add_symbol(symbol);
  builder_.add_sandbox_enabled(sandbox_enabled);
  builder_.add_active(active);
  builder_.add_crypto_quote(crypto_quote);
  builder_.add_crypto_base(crypto_base);
  builder_.add_exchange(exchange);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Instrument> CreateInstrumentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    InstrumentType type = InstrumentType_UNKNOWN,
    const char *symbol = nullptr,
    Exchange exchange = Exchange_SIM,
    const char *exchange_symbol = nullptr,
    double tick_size = 0.0,
    double min_size = 0.0,
    double max_size = 0.0,
    Currency crypto_base = Currency_UNKNOWN,
    Currency crypto_quote = Currency_UNKNOWN,
    bool active = false,
    bool sandbox_enabled = false) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto exchange_symbol__ = exchange_symbol ? _fbb.CreateString(exchange_symbol) : 0;
  return krypto::serialization::CreateInstrument(
      _fbb,
      id,
      type,
      symbol__,
      exchange,
      exchange_symbol__,
      tick_size,
      min_size,
      max_size,
      crypto_base,
      crypto_quote,
      active,
      sandbox_enabled);
}

struct Quote FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_BID = 8,
    VT_ASK = 10,
    VT_LAST = 12,
    VT_BID_QUANTITY = 14,
    VT_ASK_QUANTITY = 16,
    VT_LAST_QUANTITY = 18
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  int64_t bid() const {
    return GetField<int64_t>(VT_BID, 0);
  }
  int64_t ask() const {
    return GetField<int64_t>(VT_ASK, 0);
  }
  int64_t last() const {
    return GetField<int64_t>(VT_LAST, 0);
  }
  int64_t bid_quantity() const {
    return GetField<int64_t>(VT_BID_QUANTITY, 0);
  }
  int64_t ask_quantity() const {
    return GetField<int64_t>(VT_ASK_QUANTITY, 0);
  }
  int64_t last_quantity() const {
    return GetField<int64_t>(VT_LAST_QUANTITY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyField<int64_t>(verifier, VT_BID) &&
           VerifyField<int64_t>(verifier, VT_ASK) &&
           VerifyField<int64_t>(verifier, VT_LAST) &&
           VerifyField<int64_t>(verifier, VT_BID_QUANTITY) &&
           VerifyField<int64_t>(verifier, VT_ASK_QUANTITY) &&
           VerifyField<int64_t>(verifier, VT_LAST_QUANTITY) &&
           verifier.EndTable();
  }
};

struct QuoteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Quote::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(Quote::VT_SECURITY_ID, security_id, 0);
  }
  void add_bid(int64_t bid) {
    fbb_.AddElement<int64_t>(Quote::VT_BID, bid, 0);
  }
  void add_ask(int64_t ask) {
    fbb_.AddElement<int64_t>(Quote::VT_ASK, ask, 0);
  }
  void add_last(int64_t last) {
    fbb_.AddElement<int64_t>(Quote::VT_LAST, last, 0);
  }
  void add_bid_quantity(int64_t bid_quantity) {
    fbb_.AddElement<int64_t>(Quote::VT_BID_QUANTITY, bid_quantity, 0);
  }
  void add_ask_quantity(int64_t ask_quantity) {
    fbb_.AddElement<int64_t>(Quote::VT_ASK_QUANTITY, ask_quantity, 0);
  }
  void add_last_quantity(int64_t last_quantity) {
    fbb_.AddElement<int64_t>(Quote::VT_LAST_QUANTITY, last_quantity, 0);
  }
  explicit QuoteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuoteBuilder &operator=(const QuoteBuilder &);
  flatbuffers::Offset<Quote> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quote>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quote> CreateQuote(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    int64_t bid = 0,
    int64_t ask = 0,
    int64_t last = 0,
    int64_t bid_quantity = 0,
    int64_t ask_quantity = 0,
    int64_t last_quantity = 0) {
  QuoteBuilder builder_(_fbb);
  builder_.add_last_quantity(last_quantity);
  builder_.add_ask_quantity(ask_quantity);
  builder_.add_bid_quantity(bid_quantity);
  builder_.add_last(last);
  builder_.add_ask(ask);
  builder_.add_bid(bid);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

struct Snapshot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_BIDS = 8,
    VT_ASKS = 10
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  const flatbuffers::Vector<const SnapshotPriceLevel *> *bids() const {
    return GetPointer<const flatbuffers::Vector<const SnapshotPriceLevel *> *>(VT_BIDS);
  }
  const flatbuffers::Vector<const SnapshotPriceLevel *> *asks() const {
    return GetPointer<const flatbuffers::Vector<const SnapshotPriceLevel *> *>(VT_ASKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) &&
           VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) &&
           verifier.EndTable();
  }
};

struct SnapshotBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Snapshot::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(Snapshot::VT_SECURITY_ID, security_id, 0);
  }
  void add_bids(flatbuffers::Offset<flatbuffers::Vector<const SnapshotPriceLevel *>> bids) {
    fbb_.AddOffset(Snapshot::VT_BIDS, bids);
  }
  void add_asks(flatbuffers::Offset<flatbuffers::Vector<const SnapshotPriceLevel *>> asks) {
    fbb_.AddOffset(Snapshot::VT_ASKS, asks);
  }
  explicit SnapshotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SnapshotBuilder &operator=(const SnapshotBuilder &);
  flatbuffers::Offset<Snapshot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Snapshot>(end);
    return o;
  }
};

inline flatbuffers::Offset<Snapshot> CreateSnapshot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SnapshotPriceLevel *>> bids = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SnapshotPriceLevel *>> asks = 0) {
  SnapshotBuilder builder_(_fbb);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  return builder_.Finish();
}

inline flatbuffers::Offset<Snapshot> CreateSnapshotDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    const std::vector<SnapshotPriceLevel> *bids = nullptr,
    const std::vector<SnapshotPriceLevel> *asks = nullptr) {
  auto bids__ = bids ? _fbb.CreateVectorOfStructs<SnapshotPriceLevel>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVectorOfStructs<SnapshotPriceLevel>(*asks) : 0;
  return krypto::serialization::CreateSnapshot(
      _fbb,
      timestamp,
      security_id,
      bids__,
      asks__);
}

struct Incremental FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_UPDATES = 8
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  const flatbuffers::Vector<const IncrementalPriceLevel *> *updates() const {
    return GetPointer<const flatbuffers::Vector<const IncrementalPriceLevel *> *>(VT_UPDATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.VerifyVector(updates()) &&
           verifier.EndTable();
  }
};

struct IncrementalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Incremental::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(Incremental::VT_SECURITY_ID, security_id, 0);
  }
  void add_updates(flatbuffers::Offset<flatbuffers::Vector<const IncrementalPriceLevel *>> updates) {
    fbb_.AddOffset(Incremental::VT_UPDATES, updates);
  }
  explicit IncrementalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IncrementalBuilder &operator=(const IncrementalBuilder &);
  flatbuffers::Offset<Incremental> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Incremental>(end);
    return o;
  }
};

inline flatbuffers::Offset<Incremental> CreateIncremental(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<const IncrementalPriceLevel *>> updates = 0) {
  IncrementalBuilder builder_(_fbb);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  builder_.add_updates(updates);
  return builder_.Finish();
}

inline flatbuffers::Offset<Incremental> CreateIncrementalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    const std::vector<IncrementalPriceLevel> *updates = nullptr) {
  auto updates__ = updates ? _fbb.CreateVectorOfStructs<IncrementalPriceLevel>(*updates) : 0;
  return krypto::serialization::CreateIncremental(
      _fbb,
      timestamp,
      security_id,
      updates__);
}

struct Trade FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_PRICE = 8,
    VT_QUANTITY = 10,
    VT_SIDE = 12,
    VT_TRADE_ID = 14
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  int64_t price() const {
    return GetField<int64_t>(VT_PRICE, 0);
  }
  int64_t quantity() const {
    return GetField<int64_t>(VT_QUANTITY, 0);
  }
  Side side() const {
    return static_cast<Side>(GetField<int8_t>(VT_SIDE, 0));
  }
  const flatbuffers::String *trade_id() const {
    return GetPointer<const flatbuffers::String *>(VT_TRADE_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyField<int64_t>(verifier, VT_PRICE) &&
           VerifyField<int64_t>(verifier, VT_QUANTITY) &&
           VerifyField<int8_t>(verifier, VT_SIDE) &&
           VerifyOffset(verifier, VT_TRADE_ID) &&
           verifier.VerifyString(trade_id()) &&
           verifier.EndTable();
  }
};

struct TradeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Trade::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(Trade::VT_SECURITY_ID, security_id, 0);
  }
  void add_price(int64_t price) {
    fbb_.AddElement<int64_t>(Trade::VT_PRICE, price, 0);
  }
  void add_quantity(int64_t quantity) {
    fbb_.AddElement<int64_t>(Trade::VT_QUANTITY, quantity, 0);
  }
  void add_side(Side side) {
    fbb_.AddElement<int8_t>(Trade::VT_SIDE, static_cast<int8_t>(side), 0);
  }
  void add_trade_id(flatbuffers::Offset<flatbuffers::String> trade_id) {
    fbb_.AddOffset(Trade::VT_TRADE_ID, trade_id);
  }
  explicit TradeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TradeBuilder &operator=(const TradeBuilder &);
  flatbuffers::Offset<Trade> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Trade>(end);
    return o;
  }
};

inline flatbuffers::Offset<Trade> CreateTrade(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    int64_t price = 0,
    int64_t quantity = 0,
    Side side = Side_UNKNOWN,
    flatbuffers::Offset<flatbuffers::String> trade_id = 0) {
  TradeBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  builder_.add_trade_id(trade_id);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<Trade> CreateTradeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    int64_t price = 0,
    int64_t quantity = 0,
    Side side = Side_UNKNOWN,
    const char *trade_id = nullptr) {
  auto trade_id__ = trade_id ? _fbb.CreateString(trade_id) : 0;
  return krypto::serialization::CreateTrade(
      _fbb,
      timestamp,
      security_id,
      price,
      quantity,
      side,
      trade_id__);
}

struct InstrumentRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  RequestType type() const {
    return static_cast<RequestType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct InstrumentRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(RequestType type) {
    fbb_.AddElement<int8_t>(InstrumentRequest::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit InstrumentRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstrumentRequestBuilder &operator=(const InstrumentRequestBuilder &);
  flatbuffers::Offset<InstrumentRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstrumentRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstrumentRequest> CreateInstrumentRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    RequestType type = RequestType_INVALID) {
  InstrumentRequestBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct InstrumentResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUMENTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Instrument>> *instruments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Instrument>> *>(VT_INSTRUMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTRUMENTS) &&
           verifier.VerifyVector(instruments()) &&
           verifier.VerifyVectorOfTables(instruments()) &&
           verifier.EndTable();
  }
};

struct InstrumentResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instruments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Instrument>>> instruments) {
    fbb_.AddOffset(InstrumentResponse::VT_INSTRUMENTS, instruments);
  }
  explicit InstrumentResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstrumentResponseBuilder &operator=(const InstrumentResponseBuilder &);
  flatbuffers::Offset<InstrumentResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstrumentResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstrumentResponse> CreateInstrumentResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Instrument>>> instruments = 0) {
  InstrumentResponseBuilder builder_(_fbb);
  builder_.add_instruments(instruments);
  return builder_.Finish();
}

inline flatbuffers::Offset<InstrumentResponse> CreateInstrumentResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Instrument>> *instruments = nullptr) {
  auto instruments__ = instruments ? _fbb.CreateVector<flatbuffers::Offset<Instrument>>(*instruments) : 0;
  return krypto::serialization::CreateInstrumentResponse(
      _fbb,
      instruments__);
}

struct InstrumentRefreshRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InstrumentRefreshRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InstrumentRefreshRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstrumentRefreshRequestBuilder &operator=(const InstrumentRefreshRequestBuilder &);
  flatbuffers::Offset<InstrumentRefreshRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstrumentRefreshRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstrumentRefreshRequest> CreateInstrumentRefreshRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InstrumentRefreshRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OrderRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_PRICE = 8,
    VT_QUANTITY = 10,
    VT_SIDE = 12,
    VT_ORDER_ID = 14,
    VT_TIF = 16
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  int64_t price() const {
    return GetField<int64_t>(VT_PRICE, 0);
  }
  int64_t quantity() const {
    return GetField<int64_t>(VT_QUANTITY, 0);
  }
  Side side() const {
    return static_cast<Side>(GetField<int8_t>(VT_SIDE, 0));
  }
  const flatbuffers::String *order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_ID);
  }
  TimeInForce tif() const {
    return static_cast<TimeInForce>(GetField<int8_t>(VT_TIF, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyField<int64_t>(verifier, VT_PRICE) &&
           VerifyField<int64_t>(verifier, VT_QUANTITY) &&
           VerifyField<int8_t>(verifier, VT_SIDE) &&
           VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) &&
           VerifyField<int8_t>(verifier, VT_TIF) &&
           verifier.EndTable();
  }
};

struct OrderRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(OrderRequest::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(OrderRequest::VT_SECURITY_ID, security_id, 0);
  }
  void add_price(int64_t price) {
    fbb_.AddElement<int64_t>(OrderRequest::VT_PRICE, price, 0);
  }
  void add_quantity(int64_t quantity) {
    fbb_.AddElement<int64_t>(OrderRequest::VT_QUANTITY, quantity, 0);
  }
  void add_side(Side side) {
    fbb_.AddElement<int8_t>(OrderRequest::VT_SIDE, static_cast<int8_t>(side), 0);
  }
  void add_order_id(flatbuffers::Offset<flatbuffers::String> order_id) {
    fbb_.AddOffset(OrderRequest::VT_ORDER_ID, order_id);
  }
  void add_tif(TimeInForce tif) {
    fbb_.AddElement<int8_t>(OrderRequest::VT_TIF, static_cast<int8_t>(tif), 0);
  }
  explicit OrderRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderRequestBuilder &operator=(const OrderRequestBuilder &);
  flatbuffers::Offset<OrderRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderRequest> CreateOrderRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    int64_t price = 0,
    int64_t quantity = 0,
    Side side = Side_UNKNOWN,
    flatbuffers::Offset<flatbuffers::String> order_id = 0,
    TimeInForce tif = TimeInForce_DAY) {
  OrderRequestBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  builder_.add_order_id(order_id);
  builder_.add_tif(tif);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderRequest> CreateOrderRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    int64_t price = 0,
    int64_t quantity = 0,
    Side side = Side_UNKNOWN,
    const char *order_id = nullptr,
    TimeInForce tif = TimeInForce_DAY) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  return krypto::serialization::CreateOrderRequest(
      _fbb,
      timestamp,
      security_id,
      price,
      quantity,
      side,
      order_id__,
      tif);
}

struct OrderCancelRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_ORDER_ID = 6
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::String *order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) &&
           verifier.EndTable();
  }
};

struct OrderCancelRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(OrderCancelRequest::VT_TIMESTAMP, timestamp, 0);
  }
  void add_order_id(flatbuffers::Offset<flatbuffers::String> order_id) {
    fbb_.AddOffset(OrderCancelRequest::VT_ORDER_ID, order_id);
  }
  explicit OrderCancelRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderCancelRequestBuilder &operator=(const OrderCancelRequestBuilder &);
  flatbuffers::Offset<OrderCancelRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderCancelRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderCancelRequest> CreateOrderCancelRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> order_id = 0) {
  OrderCancelRequestBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_order_id(order_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderCancelRequest> CreateOrderCancelRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    const char *order_id = nullptr) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  return krypto::serialization::CreateOrderCancelRequest(
      _fbb,
      timestamp,
      order_id__);
}

struct OrderReplaceRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_ORDER_ID = 6,
    VT_PRICE = 8,
    VT_QUANTITY = 10,
    VT_SIDE = 12
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::String *order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_ID);
  }
  int64_t price() const {
    return GetField<int64_t>(VT_PRICE, 0);
  }
  int64_t quantity() const {
    return GetField<int64_t>(VT_QUANTITY, 0);
  }
  Side side() const {
    return static_cast<Side>(GetField<int8_t>(VT_SIDE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) &&
           VerifyField<int64_t>(verifier, VT_PRICE) &&
           VerifyField<int64_t>(verifier, VT_QUANTITY) &&
           VerifyField<int8_t>(verifier, VT_SIDE) &&
           verifier.EndTable();
  }
};

struct OrderReplaceRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(OrderReplaceRequest::VT_TIMESTAMP, timestamp, 0);
  }
  void add_order_id(flatbuffers::Offset<flatbuffers::String> order_id) {
    fbb_.AddOffset(OrderReplaceRequest::VT_ORDER_ID, order_id);
  }
  void add_price(int64_t price) {
    fbb_.AddElement<int64_t>(OrderReplaceRequest::VT_PRICE, price, 0);
  }
  void add_quantity(int64_t quantity) {
    fbb_.AddElement<int64_t>(OrderReplaceRequest::VT_QUANTITY, quantity, 0);
  }
  void add_side(Side side) {
    fbb_.AddElement<int8_t>(OrderReplaceRequest::VT_SIDE, static_cast<int8_t>(side), 0);
  }
  explicit OrderReplaceRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderReplaceRequestBuilder &operator=(const OrderReplaceRequestBuilder &);
  flatbuffers::Offset<OrderReplaceRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderReplaceRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderReplaceRequest> CreateOrderReplaceRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> order_id = 0,
    int64_t price = 0,
    int64_t quantity = 0,
    Side side = Side_UNKNOWN) {
  OrderReplaceRequestBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_price(price);
  builder_.add_timestamp(timestamp);
  builder_.add_order_id(order_id);
  builder_.add_side(side);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderReplaceRequest> CreateOrderReplaceRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    const char *order_id = nullptr,
    int64_t price = 0,
    int64_t quantity = 0,
    Side side = Side_UNKNOWN) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  return krypto::serialization::CreateOrderReplaceRequest(
      _fbb,
      timestamp,
      order_id__,
      price,
      quantity,
      side);
}

struct OrderUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_ORDER_ID = 6,
    VT_EXCHANGE_ORDER_ID = 8,
    VT_STATUS = 10,
    VT_FILLED_QUANTITY = 12
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::String *order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ORDER_ID);
  }
  const flatbuffers::String *exchange_order_id() const {
    return GetPointer<const flatbuffers::String *>(VT_EXCHANGE_ORDER_ID);
  }
  OrderStatus status() const {
    return static_cast<OrderStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  int64_t filled_quantity() const {
    return GetField<int64_t>(VT_FILLED_QUANTITY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_ORDER_ID) &&
           verifier.VerifyString(order_id()) &&
           VerifyOffset(verifier, VT_EXCHANGE_ORDER_ID) &&
           verifier.VerifyString(exchange_order_id()) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           VerifyField<int64_t>(verifier, VT_FILLED_QUANTITY) &&
           verifier.EndTable();
  }
};

struct OrderUpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(OrderUpdate::VT_TIMESTAMP, timestamp, 0);
  }
  void add_order_id(flatbuffers::Offset<flatbuffers::String> order_id) {
    fbb_.AddOffset(OrderUpdate::VT_ORDER_ID, order_id);
  }
  void add_exchange_order_id(flatbuffers::Offset<flatbuffers::String> exchange_order_id) {
    fbb_.AddOffset(OrderUpdate::VT_EXCHANGE_ORDER_ID, exchange_order_id);
  }
  void add_status(OrderStatus status) {
    fbb_.AddElement<int8_t>(OrderUpdate::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_filled_quantity(int64_t filled_quantity) {
    fbb_.AddElement<int64_t>(OrderUpdate::VT_FILLED_QUANTITY, filled_quantity, 0);
  }
  explicit OrderUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderUpdateBuilder &operator=(const OrderUpdateBuilder &);
  flatbuffers::Offset<OrderUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrderUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrderUpdate> CreateOrderUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> order_id = 0,
    flatbuffers::Offset<flatbuffers::String> exchange_order_id = 0,
    OrderStatus status = OrderStatus_UNKNOWN,
    int64_t filled_quantity = 0) {
  OrderUpdateBuilder builder_(_fbb);
  builder_.add_filled_quantity(filled_quantity);
  builder_.add_timestamp(timestamp);
  builder_.add_exchange_order_id(exchange_order_id);
  builder_.add_order_id(order_id);
  builder_.add_status(status);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrderUpdate> CreateOrderUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    const char *order_id = nullptr,
    const char *exchange_order_id = nullptr,
    OrderStatus status = OrderStatus_UNKNOWN,
    int64_t filled_quantity = 0) {
  auto order_id__ = order_id ? _fbb.CreateString(order_id) : 0;
  auto exchange_order_id__ = exchange_order_id ? _fbb.CreateString(exchange_order_id) : 0;
  return krypto::serialization::CreateOrderUpdate(
      _fbb,
      timestamp,
      order_id__,
      exchange_order_id__,
      status,
      filled_quantity);
}

struct Order FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUEST = 4,
    VT_UPDATES = 6,
    VT_FEES = 8
  };
  const OrderRequest *request() const {
    return GetPointer<const OrderRequest *>(VT_REQUEST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OrderUpdate>> *updates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OrderUpdate>> *>(VT_UPDATES);
  }
  double fees() const {
    return GetField<double>(VT_FEES, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           verifier.VerifyTable(request()) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.VerifyVector(updates()) &&
           verifier.VerifyVectorOfTables(updates()) &&
           VerifyField<double>(verifier, VT_FEES) &&
           verifier.EndTable();
  }
};

struct OrderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_request(flatbuffers::Offset<OrderRequest> request) {
    fbb_.AddOffset(Order::VT_REQUEST, request);
  }
  void add_updates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OrderUpdate>>> updates) {
    fbb_.AddOffset(Order::VT_UPDATES, updates);
  }
  void add_fees(double fees) {
    fbb_.AddElement<double>(Order::VT_FEES, fees, 0.0);
  }
  explicit OrderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderBuilder &operator=(const OrderBuilder &);
  flatbuffers::Offset<Order> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Order>(end);
    return o;
  }
};

inline flatbuffers::Offset<Order> CreateOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<OrderRequest> request = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OrderUpdate>>> updates = 0,
    double fees = 0.0) {
  OrderBuilder builder_(_fbb);
  builder_.add_fees(fees);
  builder_.add_updates(updates);
  builder_.add_request(request);
  return builder_.Finish();
}

inline flatbuffers::Offset<Order> CreateOrderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<OrderRequest> request = 0,
    const std::vector<flatbuffers::Offset<OrderUpdate>> *updates = nullptr,
    double fees = 0.0) {
  auto updates__ = updates ? _fbb.CreateVector<flatbuffers::Offset<OrderUpdate>>(*updates) : 0;
  return krypto::serialization::CreateOrder(
      _fbb,
      request,
      updates__,
      fees);
}

struct RiskSummary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_POSITIONS = 6,
    VT_PNL = 8
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::Vector<const Position *> *positions() const {
    return GetPointer<const flatbuffers::Vector<const Position *> *>(VT_POSITIONS);
  }
  double pnl() const {
    return GetField<double>(VT_PNL, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(positions()) &&
           VerifyField<double>(verifier, VT_PNL) &&
           verifier.EndTable();
  }
};

struct RiskSummaryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(RiskSummary::VT_TIMESTAMP, timestamp, 0);
  }
  void add_positions(flatbuffers::Offset<flatbuffers::Vector<const Position *>> positions) {
    fbb_.AddOffset(RiskSummary::VT_POSITIONS, positions);
  }
  void add_pnl(double pnl) {
    fbb_.AddElement<double>(RiskSummary::VT_PNL, pnl, 0.0);
  }
  explicit RiskSummaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RiskSummaryBuilder &operator=(const RiskSummaryBuilder &);
  flatbuffers::Offset<RiskSummary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiskSummary>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiskSummary> CreateRiskSummary(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Position *>> positions = 0,
    double pnl = 0.0) {
  RiskSummaryBuilder builder_(_fbb);
  builder_.add_pnl(pnl);
  builder_.add_timestamp(timestamp);
  builder_.add_positions(positions);
  return builder_.Finish();
}

inline flatbuffers::Offset<RiskSummary> CreateRiskSummaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    const std::vector<Position> *positions = nullptr,
    double pnl = 0.0) {
  auto positions__ = positions ? _fbb.CreateVectorOfStructs<Position>(*positions) : 0;
  return krypto::serialization::CreateRiskSummary(
      _fbb,
      timestamp,
      positions__,
      pnl);
}

struct TheoreticalSnapshot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_SECURITY_ID = 6,
    VT_PRICE = 8,
    VT_ADJUSTED_PRICE = 10,
    VT_ERROR = 12,
    VT_MM_BASE_BID = 14,
    VT_MM_BASE_ASK = 16,
    VT_MM_BASE_SPREAD = 18,
    VT_BID_LIQUIDITY = 20,
    VT_ASK_LIQUIDITY = 22
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  int64_t security_id() const {
    return GetField<int64_t>(VT_SECURITY_ID, 0);
  }
  double price() const {
    return GetField<double>(VT_PRICE, 0.0);
  }
  double adjusted_price() const {
    return GetField<double>(VT_ADJUSTED_PRICE, 0.0);
  }
  double error() const {
    return GetField<double>(VT_ERROR, 0.0);
  }
  double mm_base_bid() const {
    return GetField<double>(VT_MM_BASE_BID, 0.0);
  }
  double mm_base_ask() const {
    return GetField<double>(VT_MM_BASE_ASK, 0.0);
  }
  double mm_base_spread() const {
    return GetField<double>(VT_MM_BASE_SPREAD, 0.0);
  }
  double bid_liquidity() const {
    return GetField<double>(VT_BID_LIQUIDITY, 0.0);
  }
  double ask_liquidity() const {
    return GetField<double>(VT_ASK_LIQUIDITY, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_SECURITY_ID) &&
           VerifyField<double>(verifier, VT_PRICE) &&
           VerifyField<double>(verifier, VT_ADJUSTED_PRICE) &&
           VerifyField<double>(verifier, VT_ERROR) &&
           VerifyField<double>(verifier, VT_MM_BASE_BID) &&
           VerifyField<double>(verifier, VT_MM_BASE_ASK) &&
           VerifyField<double>(verifier, VT_MM_BASE_SPREAD) &&
           VerifyField<double>(verifier, VT_BID_LIQUIDITY) &&
           VerifyField<double>(verifier, VT_ASK_LIQUIDITY) &&
           verifier.EndTable();
  }
};

struct TheoreticalSnapshotBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(TheoreticalSnapshot::VT_TIMESTAMP, timestamp, 0);
  }
  void add_security_id(int64_t security_id) {
    fbb_.AddElement<int64_t>(TheoreticalSnapshot::VT_SECURITY_ID, security_id, 0);
  }
  void add_price(double price) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_PRICE, price, 0.0);
  }
  void add_adjusted_price(double adjusted_price) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_ADJUSTED_PRICE, adjusted_price, 0.0);
  }
  void add_error(double error) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_ERROR, error, 0.0);
  }
  void add_mm_base_bid(double mm_base_bid) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_MM_BASE_BID, mm_base_bid, 0.0);
  }
  void add_mm_base_ask(double mm_base_ask) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_MM_BASE_ASK, mm_base_ask, 0.0);
  }
  void add_mm_base_spread(double mm_base_spread) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_MM_BASE_SPREAD, mm_base_spread, 0.0);
  }
  void add_bid_liquidity(double bid_liquidity) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_BID_LIQUIDITY, bid_liquidity, 0.0);
  }
  void add_ask_liquidity(double ask_liquidity) {
    fbb_.AddElement<double>(TheoreticalSnapshot::VT_ASK_LIQUIDITY, ask_liquidity, 0.0);
  }
  explicit TheoreticalSnapshotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TheoreticalSnapshotBuilder &operator=(const TheoreticalSnapshotBuilder &);
  flatbuffers::Offset<TheoreticalSnapshot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TheoreticalSnapshot>(end);
    return o;
  }
};

inline flatbuffers::Offset<TheoreticalSnapshot> CreateTheoreticalSnapshot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    int64_t security_id = 0,
    double price = 0.0,
    double adjusted_price = 0.0,
    double error = 0.0,
    double mm_base_bid = 0.0,
    double mm_base_ask = 0.0,
    double mm_base_spread = 0.0,
    double bid_liquidity = 0.0,
    double ask_liquidity = 0.0) {
  TheoreticalSnapshotBuilder builder_(_fbb);
  builder_.add_ask_liquidity(ask_liquidity);
  builder_.add_bid_liquidity(bid_liquidity);
  builder_.add_mm_base_spread(mm_base_spread);
  builder_.add_mm_base_ask(mm_base_ask);
  builder_.add_mm_base_bid(mm_base_bid);
  builder_.add_error(error);
  builder_.add_adjusted_price(adjusted_price);
  builder_.add_price(price);
  builder_.add_security_id(security_id);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

}  // namespace serialization
}  // namespace krypto

#endif  // FLATBUFFERS_GENERATED_SERIALIZATION_KRYPTO_SERIALIZATION_H_
